import os

import click

from modular_api.helpers.request_processor import generate_route_meta_mapping
from modular_api.helpers.utilities import validate_meta_keys
from modular_api.web_service.iam import filter_commands_by_permissions
from modular_api.helpers.constants import BLOCKED_STATE, REMOVED_STATE, ACTIVATED_STATE
from modular_api.services.group_service import GroupService
from modular_api.services.permissions_cache_service import permissions_handler_instance, \
    PermissionsService
from modular_api.services.policy_service import PolicyService
from modular_api.helpers.date_utils import convert_datetime_to_human_readable, utc_time_now
from modular_api.helpers.password_util import generate_password, validate_password, \
    secure_string
from modular_api.services.user_service import UserService
from modular_api.helpers.decorators import CommandResponse
from modular_api.helpers.exceptions import ModularApiConfigurationException, \
    ModularApiBadRequestException, ModularApiConflictException, \
    ModularApiUnauthorizedException

SET_META_CMD = 'modular user set_meta_attribute --key $parameter_name ' \
               '--value $parameter_value'
line_sep = os.linesep


class UserHandler:
    def __init__(self, user_service, group_service, policy_service):
        self.user_service: UserService = user_service
        self.group_service: GroupService = group_service
        self.policy_service: PolicyService = policy_service

    def add_user_handler(self, username, groups, password) -> CommandResponse:
        """
        Adds user to ModularUser table
        :param username: Username that will be set to the user
        :param groups: Group name(s) that will be attached to user
        :param password: User password
        :return: CommandResponse
        """

        existing_user = self.user_service.describe_user(username=username)
        if existing_user:
            if existing_user.state == BLOCKED_STATE:
                raise ModularApiBadRequestException(
                    f'User \'{username}\' is blocked. To unblock user please '
                    f'execute command:{line_sep}'
                    f'modular user unblock --user {username} --reason '
                    f'<$THE USER UNBLOCKING REASON>')

            elif existing_user.state == REMOVED_STATE:
                raise ModularApiBadRequestException(
                    f'User \'{username}\' already exists and marked as '
                    f'\'{REMOVED_STATE}\'')

            elif existing_user.state == ACTIVATED_STATE:
                raise ModularApiBadRequestException(
                    f'User \'{username}\' already activated.{line_sep}')

            raise ModularApiConflictException(
                f'User \'{username}\' already exists with invalid '
                f'\'{existing_user.state}\' state')

        existing_groups = self.group_service.get_groups_by_name(
            group_names=groups
        )

        if not existing_groups:
            raise ModularApiBadRequestException(
                f'One or all provided \'{", ".join(groups)}\' group(s) does not '
                f'exist.{line_sep}To add group please execute '
                f'\'modular group add --help\' command first')

        skipped_groups = list()
        for group in groups:
            if group not in [group_name.group_name for group_name in existing_groups]:
                skipped_groups.append(group)

        if skipped_groups:
            raise ModularApiBadRequestException(
                f'Group(s) you are trying to add to the user is '
                f'missing:{line_sep}{", ".join(skipped_groups)}{line_sep}'
                f'Please remove it`s name(s) from command or add this '
                f'group(s) first'
            )

        invalid_groups = []
        for group in existing_groups:
            if self.group_service.calculate_group_hash(group) != group.hash or\
                    group.state == REMOVED_STATE:
                invalid_groups.append(group.group_name)

        if invalid_groups:
            raise ModularApiBadRequestException(
                f'The following group(s) are invalid:{line_sep}'
                f'{", ".join(invalid_groups)}'
                f'{line_sep}To get more detailed information please execute'
                f'command:{line_sep}modular group describe')

        if password:
            user_password = validate_password(password)
        else:
            user_password = generate_password()

        user_item = self.user_service.create_user_entity(
            username=username,
            password=secure_string(user_password),
            group=groups)

        user_hash_sum = self.user_service.calculate_user_hash(user_item)
        user_item.hash = user_hash_sum
        self.user_service.save_user(user_item=user_item)
        click.echo(
            f'Autogenerated password: {user_password}{os.linesep}'
            f'PAY ATTENTION: You can get the user password only when '
            f'you add the new user. You can not retrieve it later. '
            f'If you lose it, you must create a new user or change password '
            f'via \'modular user change_password\' command'
        )

        return CommandResponse(
            message=f'User \'{username}\' has been successfully activated.'
                    f'{line_sep}User added to the following group(s):'
                    f'{line_sep}{", ".join(groups)}')

    def delete_user_handler(self, username) -> CommandResponse:
        """
        Deletes user from ModularUser table
        :param username: Username that will be deleted from white list
        :return: CommandResponse
        """

        existing_user = self.user_service.describe_user(username=username)
        if not existing_user:
            raise ModularApiConfigurationException(
                f'User \'{username}\' does not exist. Nothing to delete')

        if existing_user.state != ACTIVATED_STATE:
            raise ModularApiBadRequestException(
                f'User \'{username}\' is blocked or deleted.{line_sep}To get '
                f'more detailed information please execute command:{line_sep}'
                f'modular user describe --username {username}')

        if self.user_service.calculate_user_hash(existing_user) != \
                existing_user.hash:
            click.confirm(
                f'User \'{username}\' is compromised. Command execution '
                f'leads to user entity hash sum recalculation. Are you sure?',
                abort=True)

        existing_user.state = REMOVED_STATE
        existing_user.last_modification_date = utc_time_now()
        user_hash_sum = self.user_service.calculate_user_hash(existing_user)
        existing_user.hash = user_hash_sum
        self.user_service.save_user(user_item=existing_user)

        return CommandResponse(
            message=f'User {username} has been successfully deleted')

    def block_user_handler(self, username, reason) -> CommandResponse:
        """
        Change user entity state to block
        :param username: Username
        :param reason: The textual reason of user removal
        :return: CommandResponse
        """

        existed_user = self.user_service.describe_user(username=username)
        if not existed_user:
            raise ModularApiConfigurationException(
                f'User \'{username}\' does not exist. Can not block')

        if self.user_service.calculate_user_hash(existed_user) != \
                existed_user.hash:
            click.confirm(
                f'User \'{username}\' is compromised. Command execution leads '
                f'to user entity hash sum recalculation. Are you sure?',
                abort=True)

        existed_user.state = BLOCKED_STATE
        existed_user.state_reason = reason

        existed_user.last_modification_date = utc_time_now()
        user_hash_sum = self.user_service.calculate_user_hash(existed_user)
        existed_user.hash = user_hash_sum
        self.user_service.save_user(user_item=existed_user)

        return CommandResponse(
            message=f'User \'{username}\' has been successfully blocked')

    def unblock_user_handler(self, username, reason) -> CommandResponse:
        """
        Change user entity state to unblock
        :param username: Username
        :param reason: The textual reason of user returning to whitelist
        :return: CommandResponse
        """

        existed_user = self.user_service.describe_user(username=username)
        if not existed_user:
            raise ModularApiConfigurationException(
                f'User \'{username}\' does not exist. Can not unblock')

        if self.user_service.calculate_user_hash(existed_user) != \
                existed_user.hash:
            click.confirm(
                f'User \'{username}\' compromised. Command execution leads '
                f'to user entity hash sum recalculation. Are you sure?',
                abort=True)

        existed_user.state = ACTIVATED_STATE
        existed_user.state_reason = reason

        existed_user.last_modification_date = utc_time_now()
        user_hash_sum = self.user_service.calculate_user_hash(existed_user)
        existed_user.hash = user_hash_sum
        self.user_service.save_user(user_item=existed_user)

        return CommandResponse(
            message=f'User \'{username}\' has been successfully unblocked')

    def change_user_password_handler(self, username, password) -> \
            CommandResponse:
        """
        Change user password to administrator defined
        :param username: Username
        :param password: New user password
        :return: CommandResponse
        """

        existing_user = self.user_service.describe_user(username=username)
        if not existing_user:
            raise ModularApiConfigurationException(
                f'User \'{username}\' does not exists. Can not change password')

        if existing_user.state != ACTIVATED_STATE:
            raise ModularApiBadRequestException(
                f'User \'{username}\' is blocked or deleted.{line_sep}To get '
                f'more detailed information please execute command:{line_sep}'
                f'modular user describe --username {username}')

        if self.user_service.calculate_user_hash(existing_user) != \
                existing_user.hash:
            click.confirm(
                f'User \'{username}\' is compromised. Command execution leads '
                f'to user entity hash sum recalculation. Are you sure?',
                abort=True)

        existing_user.password = secure_string(
            string_to_secure=validate_password(password=password)
        )

        existing_user.last_modification_date = utc_time_now()
        user_hash_sum = self.user_service.calculate_user_hash(existing_user)
        existing_user.hash = user_hash_sum

        self.user_service.save_user(user_item=existing_user)

        return CommandResponse(
            message=f'User \'{username}\' password has been updated')

    def manage_user_groups_handler(self, username, groups, action) -> \
            CommandResponse:
        """
        Add or remove user to the group(s)
        :param username: Username
        :param groups: Group name(s) that will be attached or detached to user
        :param action: attach or detach group
        :return: CommandResponse
        """

        groups = list(set(groups))
        existing_user = self.user_service.describe_user(username=username)
        if not existing_user:
            raise ModularApiConfigurationException(
                f'User \'{username}\' does not exist. Please check spelling')

        if existing_user.state != ACTIVATED_STATE:
            raise ModularApiBadRequestException(
                f'User {username} is blocked or deleted{line_sep}To get more '
                f'detailed information please execute command:{line_sep}'
                f'modular user describe --username {username}')

        if self.user_service.calculate_user_hash(existing_user) != \
                existing_user.hash:
            click.confirm(
                f'User \'{username}\' is compromised. Command execution leads '
                f'to user entity hash sum recalculation. Are you sure?',
                abort=True)

        requested_group_items = self.group_service.get_groups_by_name(
            group_names=groups)
        if not requested_group_items:
            raise ModularApiBadRequestException(
                f'One or all from requested group(s) does not exist. '
                f'Group(s):{line_sep}{groups}')

        if len(groups) != len(requested_group_items):
            retrieved_group_names = [group.group_name
                                     for group in requested_group_items]
            not_existed_policies = [group for group in groups
                                    if group not in retrieved_group_names]
            if not_existed_policies:
                raise ModularApiBadRequestException(
                    f'The following groups does not exists: '
                    f'{", ".join(not_existed_policies)}')

        invalid_groups = []
        for group in requested_group_items:
            if self.group_service.calculate_group_hash(group) != group.hash \
                    and group.state != ACTIVATED_STATE:
                invalid_groups.append(group.group_name)

        if invalid_groups:
            raise ModularApiBadRequestException(
                f'The following group(s) compromised or deleted:{line_sep}'
                f'{", ".join(invalid_groups)}.{line_sep}To get more detailed'
                f' information please execute command:{line_sep}'
                f'modular group describe')

        warnings_list = []
        user_groups = existing_user.groups
        if action == 'add':
            existed_group_in_user = set(groups).intersection(user_groups)
            if existed_group_in_user:
                warnings_list.append(
                    f'User already attached to the following groups: '
                    f'{", ".join(existed_group_in_user)}')
            existing_user.groups = list(set(user_groups).union(set(groups)))

        elif action == 'remove':
            not_existed_group_in_user = set(groups).difference(user_groups)
            if not_existed_group_in_user:
                warnings_list.append(
                    f'The following groups does not attached to the user: '
                    f'{", ".join(not_existed_group_in_user)}')
            existing_user.groups = list(set(user_groups) - set(groups))
        else:
            raise ModularApiBadRequestException('Invalid action requested')

        existing_user.last_modification_date = utc_time_now()
        user_hash_sum = self.user_service.calculate_user_hash(existing_user)
        existing_user.hash = user_hash_sum
        self.user_service.save_user(user_item=existing_user)

        return CommandResponse(
            message=f'User \'{username}\' has been updated',
            warnings=warnings_list)

    @staticmethod
    def check_user_items_exist(user_items: list) -> None:
        if not user_items:
            raise ModularApiBadRequestException(
                'User(s) does not exist. To add user please execute '
                '\'modular user add\' command')

    def resolve_policy_allowed_actions(self, policies):
        actions = []
        errors = []
        for policy in policies:
            received_policy = self.policy_service.describe_policy(
                policy_name=policy)
            if not received_policy:
                errors.append(f'Policy \'{policy}\' does not exist')
                continue
            if received_policy.hash != self.policy_service.calculate_policy_hash(
                    policy_item=received_policy):
                errors.append(
                    f'Policy \'{policy}\' is compromised. Calculated hash sum is '
                    f'different from existed in entity.')
            actions.extend(received_policy.policy_content)
        return actions, errors

    def validate_groups_policies_and_resolve_actions(self, groups):
        errors_list = []
        actions_list = []
        for group in groups:
            received_group = self.group_service.describe_group(
                group_name=group)
            if not received_group:
                errors_list.append(f'Group \'{group}\' does not exist')
                continue

            if received_group.hash != self.group_service.calculate_group_hash(
                    group_item=received_group):
                errors_list.append(
                    f'Group {group} is compromised. Calculated hash sum is '
                    f'different from existed in entity.')

            actions, errors = self.resolve_policy_allowed_actions(
                policies=received_group.policies
            )
            errors_list.extend(errors)
            actions_list.extend(actions)
        return errors_list, actions_list

    @staticmethod
    def prettify_user_item(user, user_compromised,
                           policy_group_compromised=False):
        is_compromised = any([user_compromised, policy_group_compromised])
        return {
            'Username': user.username,
            'Groups': user.groups,
            'State': user.state,
            'State reason': user.state_reason,
            'User meta': user.meta.as_dict() if user.meta else None,
            'Modification date': convert_datetime_to_human_readable(
                datetime_object=user.last_modification_date
            ),
            'Creation Date': convert_datetime_to_human_readable(
                datetime_object=user.creation_date
            ),
            'Consistency status': 'Compromised' if is_compromised else 'OK'
        }

    def describe_single_user(self, username):
        existed_user = self.user_service.describe_user(
            username=username)

        if not existed_user:
            raise ModularApiBadRequestException(f'No such user: \'{username}\'')

        policies_groups_warnings, _ = \
            self.validate_groups_policies_and_resolve_actions(
                groups=existed_user.groups
            )

        user_compromised = self.user_service.calculate_user_hash(
            user_item=existed_user) != existed_user.hash

        is_policies_groups_compromised = True if policies_groups_warnings else False
        pretty_user = self.prettify_user_item(
            user=existed_user,
            user_compromised=user_compromised,
            policy_group_compromised=is_policies_groups_compromised
        )

        return CommandResponse(
            table_title='User description',
            warnings=policies_groups_warnings,
            items=[pretty_user])

    def policy_simulator_handler(self, user_name, user_group, policy_name,
                                 requested_command):
        warnings_list = []
        policies = []
        item_name = ''
        item = ''
        if user_name:
            existed_user = self.user_service.describe_user(
                username=user_name)

            if not existed_user:
                raise ModularApiBadRequestException(
                    f'No such user: \'{user_name}\'')

            warnings_list, policies = \
                self.validate_groups_policies_and_resolve_actions(
                    groups=existed_user.groups
                )
            item, item_name = 'user', user_name

        elif user_group:
            warnings_list, policies = \
                self.validate_groups_policies_and_resolve_actions(
                    groups=[user_group]
                )
            item, item_name = 'group', user_group
        elif policy_name:
            policies, warnings_list = self.resolve_policy_allowed_actions(
                policies=[policy_name]
            )
            item, item_name = 'policy', policy_name

        if warnings_list:
            return CommandResponse(
                message='Any action can not be performed due to '
                        'user/group/policy invalid configuration',
                warnings=warnings_list
            )

        if not requested_command.startswith('admin '):
            raise ModularApiBadRequestException(
                'Incorrect spelling. All commands should starting '
                'with "admin ..."'
            )
        if '-' in requested_command:
            raise ModularApiBadRequestException(
                'Incorrect spelling. "-" and "--" symbols are not allowed. '
                'Check spelling'
            )
        available_commands = permissions_handler_instance().available_commands
        filtered_commands = filter_commands_by_permissions(available_commands,
                                                           policies)

        route_mapping = generate_route_meta_mapping(commands_meta=filtered_commands)

        init_cmd = requested_command
        requested_command = requested_command.split()
        path = '/'.join(requested_command).replace('admin', '')
        # for admin root commands
        # if will be added new one -> add to list:
        if path == '/get_operation_status':
            path = '/admin/get_operation_status'
        # ----------------------------------------
        effect = 'ALLOW' if path in route_mapping.keys() else 'DENY'

        return CommandResponse(
            f'Checked for {item}: {item_name}{os.linesep}'
            f'Command: {init_cmd}{os.linesep}'
            f'Status: {effect}{os.linesep}'
        )

    def describe_user_handler(self, username) -> CommandResponse:
        """
        Describes user entity from User model or list all existed users
        :param username: Username that will be deleted from white list
        :return: CommandResponse
        """

        if username:
            return self.describe_single_user(username=username)

        existed_users = self.user_service.scan_users()
        self.check_user_items_exist(user_items=existed_users)

        pretty_users = []
        invalid = 0
        for user in existed_users:
            is_compromised = self.user_service.calculate_user_hash(
                user_item=user) != user.hash
            if is_compromised:
                invalid += 1

            pretty_user_item = self.prettify_user_item(
                user=user,
                user_compromised=is_compromised
            )
            pretty_users.append(pretty_user_item)
        valid_title = 'User(s) description'
        compromised_title = f'User(s) description{os.linesep}WARNING! ' \
                            f'{invalid} compromised users have been detected.'

        return CommandResponse(
            table_title=compromised_title if invalid else valid_title,
            items=pretty_users)

    def set_user_meta_handler(self, username, key, values):
        user = self.check_existence_and_get_user(username)
        self.check_user_validness(user)
        validate_meta_keys(key)
        if not user.meta:
            user.meta = {}
        action = 'replaced' if key in user.meta.attribute_values.keys() else 'set'
        user.meta[key] = list(set(values))
        user.last_modification_date = utc_time_now()
        self.user_service.save_user_with_recalculated_hash(user)
        return CommandResponse(
            message=f'Meta information for user \'{username}\' has been '
                    f'successfully {action}'
        )

    def update_user_meta_handler(self, username, key, values):
        user = self.check_existence_and_get_user(username)
        self.check_user_validness(user)
        if not user.meta:
            raise ModularApiBadRequestException(
                f'User \'{username}\' has no meta, nothing to update.'
                f'{os.linesep}Please set meta first with the command '
                f'\'{SET_META_CMD}\''
            )
        validate_meta_keys(key)
        if key in user.meta.attribute_values.keys():
            values_list = user.meta.attribute_values.get(key)
            values_list.extend(list(values))
            user.meta[key] = list(set(values_list))
        else:
            raise ModularApiBadRequestException(
                f'User \'{username}\' has no parameter name \'{key}\' in meta, '
                f'nothing to update.{os.linesep}Set parameter name first with '
                f'the command \'{SET_META_CMD}\''
            )
        user.last_modification_date = utc_time_now()
        self.user_service.save_user_with_recalculated_hash(user)
        return CommandResponse(
            message=f'Meta information for user \'{username}\' has been '
                    f'successfully updated'
        )

    def delete_user_meta_handler(self, username, keys):
        user = self.check_existence_and_get_user(username)
        self.check_user_validness(user)
        if not user.meta:
            raise ModularApiBadRequestException(
                f'User \'{username}\' has no meta, nothing to delete.'
                f'{os.linesep}Please set meta first with the command '
                f'\'{SET_META_CMD}\''
            )
        skipped_keys = []
        removed_keys = []
        for key in keys:
            if key not in user.meta.attribute_values.keys():
                skipped_keys.append(key)
                continue
            user.meta.attribute_values.pop(key)
            removed_keys.append(key)
        if removed_keys:
            user.last_modification_date = utc_time_now()
            self.user_service.save_user_with_recalculated_hash(user)
            message = f'Deleted parameter(s) name from \'{username}\' meta: ' \
                      f'{removed_keys}'
        else:
            message = f'No parameter(s) name has been removed from ' \
                      f'\'{username}\' meta'
        if skipped_keys:
            message += f'{os.linesep}Next parameter(s) name deletion skipped ' \
                       f'due to its absence in user meta: {skipped_keys}'
        return CommandResponse(message=message)

    def reset_user_meta_handler(self, username):
        user = self.check_existence_and_get_user(username)
        self.check_user_validness(user)
        if not user.meta or not user.meta.attribute_values.keys():
            raise ModularApiBadRequestException(
                f'User \'{username}\' has no meta, nothing to reset.'
                f'{os.linesep}Please set meta first with the command '
                f'\'{SET_META_CMD}\''
            )
        user.meta = {}
        user.last_modification_date = utc_time_now()
        self.user_service.save_user_with_recalculated_hash(user)
        return CommandResponse(
            message=f'All data in user \'{username}\' meta has been deleted'
        )

    def describe_user_meta_handler(self, username):
        user = self.check_existence_and_get_user(username)
        items = []
        if not user.meta or not user.meta.attribute_values.keys():
            return CommandResponse(
                message=f'Nothing to describe. User \'{username}\' has no meta'
            )
        for item in user.meta.attribute_values.keys():
            values = user.meta.attribute_values[item]
            values.sort()
            result = ', '.join(values)
            items.append(
                {
                    "Parameter name": item,
                    "Parameter values": result
                }
            )
        return CommandResponse(
            table_title=f"Meta information for user \'{username}\'",
            items=items
        )

    def check_user_validness(self, user):
        try:
            PermissionsService(
                user_service=self.user_service,
                group_service=self.group_service,
                policy_service=self.policy_service
            ).check_user_item_is_valid(user)
        except ModularApiUnauthorizedException:
            raise ModularApiBadRequestException(
                'The User item you are trying to modify is compromised. '
                'Can not perform command execution'
            )

    def check_existence_and_get_user(self, username):
        user = self.user_service.describe_user(username=username)
        if not user:
            raise ModularApiBadRequestException(
                f'User with name \'{username}\' does not exist'
            )
        return user
